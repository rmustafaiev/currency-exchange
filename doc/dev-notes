
Что не сделано
- Пагинация,
- Проверка входных данных запросов: типы, значения (валидация must have)
- Тесты e2e и интеграционные (must have)
- архитетура приложения, структура, некоторые модули tightly coupled
- задача по ограничению доступа и запрета для для модификаций

Что сделано
- Базовая реализация АПИ.
- Базовая обработка ошибок.
- Миграция, организация изначальной схемы плюс заполнение таблиц.
- Документация, есть описанная задача спецификация (бери, делай)
- Файл логер, примитивный, но можно расширить.
- Докер контейнер для постгрес БД
- Выверенный setup, не использовано никаких бойлпрейтов итп
- Код написан наиболее выверно и независимо, следовательно легко рефакторить,

Что следовало сделать и какие решения
* Поиск по историческим значениям, в случаем если нет значений в пропущенный период.
Пути решения.
Тут несколько вариантов,
1. разрешить по запросу пользователя игнорировать Даты с пустыми данными, пропускать их
2. выдать ошибку что в данном периоде нет данных
Как
   - написать сложный запрос итп
   - просто сделать COUNT по критерию и вычислить

* Пагинация
Как?
    сортировка к запросу + использовать LIMIT n ... OFFSET  X+n

Валидация входных параметров:
Тесты e2e + unit (must have)
    надо реализовать

* Задача по ограничению доступа
самый простой вариант,
- header Authorization = am9objpzZWNyZXQ
то есть проверять хедеры на наличие авториз. ключа\пароля.
вариант получше использовать JWT tokens
выданные авториз сервером.

* Задача по ограничению на редактирование
если 2 и более пользователей попытаються редактировать.
- реализуем lock/acquire то есть первый забирает себе запись\документ,
система делает метку на ресурс, что он используеться, будь то запись в таблицу или кеш,
после того как пользователь завершил свои действия, либо сессия закончилась
система разблокирует доступ к ресурсу.


- Архитетура приложения, структура, некоторые модули tightly coupled
На данном этапе приложение сырое,
надо провести рефакторинг в частности убрать зависимости из контроллеров итд.

Я бы добавил DI/IoC, DI container,
например
//App.js
// Service Locator
const diContainer = require('./di-container')()
diContainer.register('dbUrl', config.dbUrl...)
diContainer.factory('connection', require('./data-access/db-connection'))
diContainer.factory('RatesDb', require('./data-access/rates-db'))
diContainer.factory('RateController', require('./api/controller'))

...

//
const rateController = prodDIContainer.get('RateController');

app.get('/api/rates', (req, res) => {
	rateController.getRates((err, query params) => {
	    ...
	}
}
То есть у нас есть реестр с русурсами но с минусом завсисимотей,
модули становяться более автономными.

--
Либо же CLEAN архитектуру, детальнее тут
https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html#the-dependency-rule
видео
https://www.youtube.com/watch?v=Nsjsiz2A9mg
https://www.youtube.com/watch?v=CnailTcJV_U&t=108s

не уверен что это серебрянная пуля, но на первый взгляд выглядит хорошо, очень хорошо.
хотя вижу что увеличиваеться кол-во сущностей участников, зато CLEAN!
--
ну вообще нужно исходить из требований, задачи и искать решение под что то
конкретное.
